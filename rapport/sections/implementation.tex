\documentclass[../main.tex]{subfiles}

\begin{document}

\chapter{Implementation}

Section \ref{section_implem_structure} presents the global structure of the algorithm, then details some parts. Section \ref{section_implem_tests} briefly presents the tests. Finally, section \ref{section_implem_perf} discusses performance aspects.

\section{Structure}\label{section_implem_structure}

We first present here the main algorithm, and the important sub-algorithms. The implementation is mostly transparent, except for a few optimizations like computing the local solutions in 0 only once.

\begin{algorithm}[H]
	\caption{Main algorithm}
	\SetAlgoLined
	\KwIn{$f$ defined by a $a_n \frac{d^n}{dz^n}f + \dots a_0 = 0$, initial coefficients~$f_0, \dots, f_n$, order and precision}
	\KwOut{Asymptotic expansion of $f$ with at least order terms, and coefficients with given precision}
	
	\Begin{
		
		Compute the roots of $a_n$ and group them by increasing module.
		
		Initialise the sum $S$ of contributions to the asymptotic expansion.
		
		\While{No contribution confirmed}{
			Load next group G of roots
			
			\ForEach{root $\rho \in$ G}{
				Compute the contribution of $\rho$.	
			}
			
			Sum contributions of G and add to $S$
		}
		
		\KwRet{S}
	}
	
\end{algorithm}

To compute the contribution of a specific root, we use the following algorithm

\begin{algorithm}[H]
	\caption{Computing the contribution of a root}
	\SetAlgoLined
	\KwIn{All entries of the main algorithm, and a specific root $\rho$}
	\KwOut{Contribution of $\rho$ to the asymptotic expansion of $f$}
	
	\Begin{
		Compute a basis $\mathcal{B}_0$ of solutions in 0, and decompose $f$ in $\mathcal{B}_0$.
		
		Compute a basis $\mathcal{B}_\rho$ of solutions in $\rho$, and decompose $f$ in $\mathcal{B}_\rho$.
		
		Initialize a sum S of terms contributions.
		
		\ForEach{term T in the local expansions}{
			Compute an asymptotic expansion of the Taylor coefficients of T.
			
			Add to S.
		}
	}
	\KwRet{S}
\end{algorithm}




\section{Tests}\label{section_implem_tests}

We give here a list of functions, along with an associated differential operator and an asymptotic expansion. We provide a name when the Taylor series is of combinatorial interest, and a reference for the not obvious/classical cases.

%\begin{landscape}
\begin{tiny}
\begin{center}
\begin{TAB}(r)[3pt]{|c|c|c|c|}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
	$f$ & Differential operator & Asymptotic expansion & Sequence name\\
	
	$\log(1 - z)$ & $(z - 1) Dz^2 + Dz$ & $\frac{-1}{n}$ & \\
	
	$\log(1 + z)$ & $(z + 1) Dz^2 + Dz$ & $\frac{(-1)^n}{n}$ & \\
	
	$\frac{1}{1-z}$ & $(z - 1) Dz + 1$ & 1 & \\
	
	$\frac{1}{1+z}$ & $(z - 1) Dz + 1$ & $(-1)^n$ & \\
	
	$\frac{z}{1-2z}$ & $z (1 - 2z) Dz - 1$ & $2^{n - 1}$ & \\
	
	$\frac{1}{1 - z^2}$ & $(1 - z^2) Dz - 2z$ & $\begin{cases}
			1 \text{ if $n$ is even}\\
			0 \text{ otherwise}
		\end{cases}$ & \\
	
	${(1-z)}^{3/2}$
	& $2 (z - 1) Dz - 3$
	& $\frac{1}{\sqrt{\pi n^5}} \left( \frac{3}{4} + \frac{45}{32n} + \frac{1155}{512n^2} + \dots \right)$
	& \cite{Flajolet2009}\\
	
	$\arctan(z)$ & $(1 + z^2)Dz^2 + 2 z Dz$ & $\begin{cases}
	\frac{(-1)^n}{2n+1} \text{ if $n$ is odd}\\
	0 \text{ otherwise}
	\end{cases}$ & \\

	$\frac{1}{1-z} \log\left(\frac{1}{1-z}\right)$
	& $(1 - z)^2 Dz^2 - 3 (1 - z) Dz + 1$
	& $\log(n) + \gamma + \frac{1}{2n} +o\left(\frac{1}{n}\right)$
	& Harmonic numbers\\

	$\frac{z}{1 - z - z^2}$ & $(1 - z - z^2) Dz^2 - (2 + 4z)Dz - 2$ & $\frac{\varphi^n - (-\varphi)^{-n}}{\sqrt{5}}$ & Fibonacci numbers\\
	
	$\frac{1 - \sqrt{1 - 4z}}{2z}$ & $(4z^2 - z)Dz^2+(10z-2)Dz+2$ & $\frac{4^n}{\sqrt{\pi n}} \left(1 - \frac{1}{8n} + \frac{1}{128n^2} + \dots \right)$ & Catalan numbers\\
	
	${\scriptscriptstyle\frac{1 - z - \sqrt{1-2z-3z^2}}{2z}}$ & 
	${\scriptscriptstyle (3z^4 + 2z^3 - z^2)Dz^2 + (6z^3 + 3z^2 - z)Dz + 1 }$ & ${\scriptstyle \frac{\sqrt{3}}{2\sqrt{\pi}n^{3/2}} 3^n \left(1 - \frac{15}{16n} + \frac{505}{512n^2} + \dots \right)}$ &
	Motzkin numbers \cite{Flajolet2009}\\
	
	& $(4z^2 - z)Dz^2 + (14z - 2)Dz + 6$ & $\frac{4^{n}}{\pi n} \left( 4 - \frac{6}{n} + \frac{19 - 2(-1)^n}{2n^2} + \dots \right)$
		& Walks in $\mathbb{N}^2$ \cite{Melczer2020}\\
\end{TAB}
\end{center}
\end{tiny}

Here is the return of a typical call to \py{tests.sage} (slightly formatted and with few digits for convenience):

\begin{minted}[frame=lines, tabsize=4, fontsize=\tiny]{shell}
·> sage tests.sage
log(1+z) -> [-1.00000*n^(-1)*(e^(I*arg(-1)))^n + O(n^(-3)*(e^(I*arg(-1)))^n)]

log(1-z) -> [([-1.00000 +/- 1e-10])*n^(-1) + O(n^(-3))]

1/(1-z) -> [1.00000]

1/(1+z) -> [1.00000*(e^(I*arg(-1)))^n]

1/(1 - z^2) -> [[0.500000 +/- 4.77e-7] + [0.500000 +/- 4.77e-7]*(e^(I*arg(-1)))^n + O(n^(-4)) + O(n^(-4)*(e^(I*arg(-1)))^n)]

1/(1-z) * log(1/(1-z)) (H_n) -> [([1.00000 +/- 1e-10] + [+/- 5.17e-26]*I)*log(n)
									+ ([1.00000 +/- 1e-10] + [+/- 5.17e-26]*I)*euler_gamma
									+ ([-1.00000 +/- 1e-10] + [+/- 5.17e-26]*I)*log(-1)
									+ [+/- 1.63e-25] + [3.14159 +/- 3.94e-6]*I
									+ ([0.500000 +/- 1e-11]
									+ [+/- 2.59e-26]*I)*n^(-1)
									+ O(n^(-2))]

z/(1-2z) -> [[0.500000 +/- 4.77e-7]*2^n]

Arctan -> [([+/- 5.57e-15] + [-0.500000 +/- 4.77e-7]*I)*n^(-1)*(e^(I*arg(1*I)))^n
			+ ([+/- 5.57e-15] + [0.500000 +/- 4.77e-7]*I)*n^(-1)*(e^(I*arg(-1*I)))^n
			+ O(n^(-3)*(e^(I*arg(-1*I)))^n) + O(n^(-3)*(e^(I*arg(1*I)))^n)]

random walks in Z*N -> [(([2.00000 +/- 1.91e-6])/sqrt(pi))*4^n*n^(-1/2)
						+ (([-1.25000 +/- 2.51e-6])/sqrt(pi))*4^n*n^(-3/2)
						+ (([1.14062 +/- 7.34e-6])/sqrt(pi))*4^n*n^(-5/2)
						+ (([-1.1230 +/- 5.61e-5])/sqrt(pi))*4^n*n^(-7/2)
						+ O(4^n*n^(-9/2))]

random walks in N^2 -> [([1.27324 +/- 1.98e-6] + [+/- 1.57e-7]*I)*4^n*n^(-1)
						+ ([-1.90986 +/- 2.96e-6] + [+/- 2.35e-7]*I)*4^n*n^(-2)
						+ ([0.318310 +/- 7.23e-7])*4^n*n^(-3)*(e^(I*arg(-1)))^n
						+ O(4^n*n^(-3))]

Fibonacci numbers -> [[0.44721 +/- 4.20e-6]*1.618033988749895?^n + O(1.618033988749895?^n*n^(-5))]

Catalan numbers -> [(([1.00000 +/- 9.54e-7])/sqrt(pi))*4^n*n^(-3/2)
					+ (([-1.12500 +/- 4.00e-6])/sqrt(pi))*4^n*n^(-5/2)
					+ (([1.1328 +/- 2.16e-5])/sqrt(pi))*4^n*n^(-7/2)
					+ (([-1.1279 +/- 9.19e-5])/sqrt(pi))*4^n*n^(-9/2)
					+ O(4^n*n^(-5))]

Motzkin numbers -> [(([0.86602 +/- 6.62e-6])/sqrt(pi))*3^n*n^(-3/2)
					+ (([-0.81190 +/- 6.64e-6])/sqrt(pi))*3^n*n^(-5/2)
					+ (([0.8542 +/- 2.92e-5])/sqrt(pi))*3^n*n^(-7/2)
					+ (([-0.855 +/- 3.66e-4])/sqrt(pi))*3^n*n^(-9/2)
					+ O(3^n*n^(-5))]

(1-z)^(3/2) -> [0.750000/sqrt(pi)*n^(-5/2)
				+ 1.40625/sqrt(pi)*n^(-7/2)
				+ (([2.25586 +/- 6.25e-7])/sqrt(pi))*n^(-9/2)
				+ (([3.46069 +/- 3.36e-6])/sqrt(pi))*n^(-11/2)
				+ (([5.22901 +/- 1.54e-6])/sqrt(pi))*n^(-13/2)
				+ O(n^(-15/2))]

z(1-z) -> No singularity was found

(z - 1)^3 -> No singularity was found

1-z -> No singularity was found

exp(z) -> No singularity was found

sin(z) -> No singularity was found
\end{minted}

%A l'ordre 6 et 7:
%random walks in quadrant : ([1.27324 +/- 1.98e-6] + [+/- 1.57e-7]*I)*4^n*n^(-1) + ([-1.90986 +/- 2.96e-6] + [+/- 2.35e-7]*I)*4^n*n^(-2) + ([0.318310 +/- 7.23e-7])*4^n*n^(-3)*(e^(I*arg(-1)))^n + ([3.0239 +/- 5.09e-5] + [+/- 8.42e-7]*I)*4^n*n^(-3) + ([-1.4324 +/- 1.84e-5])*4^n*n^(-4)*(e^(I*arg(-1)))^n + O(4^n*n^(-4))
%git:(master) 
%seb@seb-HP-EliteBook-820-G2:pts/0->/home/seb/Dropbox/M2 fonda/mezzarobba/depot_git (0)
%·> sage tests.sage
%
%random walks in quadrant : ([1.27324 +/- 1.98e-6] + [+/- 1.57e-7]*I)*4^n*n^(-1) + ([-1.90986 +/- 2.96e-6] + [+/- 2.35e-7]*I)*4^n*n^(-2) + ([0.318310 +/- 7.23e-7])*4^n*n^(-3)*(e^(I*arg(-1)))^n + ([3.0239 +/- 5.09e-5] + [+/- 8.42e-7]*I)*4^n*n^(-3) + ([-1.4324 +/- 1.84e-5])*4^n*n^(-4)*(e^(I*arg(-1)))^n + ([-5.0134 +/- 7.11e-5] + [+/- 4.26e-6]*I)*4^n*n^(-4) + O(4^n*n^(-5)*log(n))
%git:(master) 


\section{Performance}\label{section_implem_perf}


\begin{remark}
	The following tests were only carried out through simple tools (\py{time} module from python, by averaging multiple calls, on my laptop with several other programs open, etc). Although the results seem in accordance with intuition and with the time spent on less expensive tests, one should keep in my they only give a vague idea of real performance.
	
	In particular, I did not attempt to compute the ``real'' complexity.
\end{remark}

On my laptop, it takes in average 14 seconds to compute the expansion for Motzkin numbers, with \py{order=20} and \py{precision=10^(-100)}. Computing up to \py{precision=10^(-10000)} takes about 16 seconds.
\py{order=10} and \py{precision=10^(-100)} -> 13 seconds



\end{document}